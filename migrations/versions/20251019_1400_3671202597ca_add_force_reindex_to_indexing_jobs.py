"""add force_reindex to indexing_jobs

Revision ID: 3671202597ca
Revises: 0365901259f8
Create Date: 2025-10-19 14:00:45.548485+00:00

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '3671202597ca'
down_revision: Union[str, None] = '0365901259f8'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Apply migration changes to database schema.

    This function should contain all changes to move forward from the
    previous revision to this revision.
    """
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_branch_links_task_branch'), table_name='task_branch_links')
    op.drop_table('task_branch_links')
    op.drop_index(op.f('idx_projects_database_name'), table_name='projects')
    op.drop_index(op.f('idx_projects_name'), table_name='projects')
    op.drop_table('projects')
    op.drop_index(op.f('ix_commit_links_task_commit'), table_name='task_commit_links')
    op.drop_table('task_commit_links')
    op.drop_table('task_planning_references')
    op.drop_index(op.f('ix_search_queries_created_at'), table_name='search_queries')
    op.drop_table('search_queries')
    op.drop_index(op.f('ix_task_status_history_changed_at'), table_name='task_status_history')
    op.drop_table('task_status_history')
    op.alter_column('change_events', 'detected_at',
               existing_type=postgresql.TIMESTAMP(),
               server_default=None,
               existing_nullable=False)
    op.drop_index(op.f('ix_change_events_detected_at'), table_name='change_events')
    op.drop_constraint(op.f('fk_change_events_repository_id_repositories'), 'change_events', type_='foreignkey')
    op.create_foreign_key(None, 'change_events', 'repositories', ['repository_id'], ['id'])
    op.alter_column('code_chunks', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               server_default=None,
               existing_nullable=False)
    op.alter_column('code_files', 'indexed_at',
               existing_type=postgresql.TIMESTAMP(),
               server_default=None,
               existing_nullable=False)
    op.alter_column('code_files', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               server_default=None,
               existing_nullable=False)
    op.alter_column('code_files', 'is_deleted',
               existing_type=sa.BOOLEAN(),
               server_default=None,
               existing_nullable=False)
    op.alter_column('embedding_metadata', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               server_default=None,
               existing_nullable=False)
    op.add_column('indexing_jobs', sa.Column('force_reindex', sa.Boolean(), nullable=False, server_default='false'))
    op.alter_column('indexing_jobs', 'id',
               existing_type=sa.UUID(),
               server_default=None,
               existing_nullable=False)
    op.alter_column('indexing_jobs', 'status',
               existing_type=sa.VARCHAR(length=20),
               server_default=None,
               existing_nullable=False)
    op.alter_column('indexing_jobs', 'files_indexed',
               existing_type=sa.INTEGER(),
               server_default=None,
               nullable=False)
    op.alter_column('indexing_jobs', 'chunks_created',
               existing_type=sa.INTEGER(),
               server_default=None,
               nullable=False)
    op.alter_column('indexing_jobs', 'created_at',
               existing_type=postgresql.TIMESTAMP(timezone=True),
               server_default=None,
               existing_nullable=False)
    op.drop_index(op.f('idx_active_jobs'), table_name='indexing_jobs', postgresql_where="((status)::text = ANY ((ARRAY['pending'::character varying, 'running'::character varying])::text[]))")
    op.drop_index(op.f('idx_created_at'), table_name='indexing_jobs')
    op.alter_column('repositories', 'is_active',
               existing_type=sa.BOOLEAN(),
               server_default=None,
               existing_nullable=False)
    op.alter_column('repositories', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               server_default=None,
               existing_nullable=False)
    op.drop_index(op.f('idx_project_repository'), table_name='repositories')
    op.drop_constraint(op.f('uq_repositories_path'), 'repositories', type_='unique')
    op.drop_column('repositories', 'project_id')
    # ### end Alembic commands ###


def downgrade() -> None:
    """Revert migration changes from database schema.

    This function should contain all changes to move backward from this
    revision to the previous revision. Should mirror upgrade() operations
    in reverse order.
    """
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('repositories', sa.Column('project_id', sa.VARCHAR(length=50), server_default=sa.text("'default'::character varying"), autoincrement=False, nullable=False))
    op.create_unique_constraint(op.f('uq_repositories_path'), 'repositories', ['path'], postgresql_nulls_not_distinct=False)
    op.create_index(op.f('idx_project_repository'), 'repositories', ['project_id', 'id'], unique=False)
    op.alter_column('repositories', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               server_default=sa.text('CURRENT_TIMESTAMP'),
               existing_nullable=False)
    op.alter_column('repositories', 'is_active',
               existing_type=sa.BOOLEAN(),
               server_default=sa.text('true'),
               existing_nullable=False)
    op.create_index(op.f('idx_created_at'), 'indexing_jobs', [sa.literal_column('created_at DESC')], unique=False)
    op.create_index(op.f('idx_active_jobs'), 'indexing_jobs', ['project_id', 'status'], unique=False, postgresql_where="((status)::text = ANY ((ARRAY['pending'::character varying, 'running'::character varying])::text[]))")
    op.alter_column('indexing_jobs', 'created_at',
               existing_type=postgresql.TIMESTAMP(timezone=True),
               server_default=sa.text('now()'),
               existing_nullable=False)
    op.alter_column('indexing_jobs', 'chunks_created',
               existing_type=sa.INTEGER(),
               server_default=sa.text('0'),
               nullable=True)
    op.alter_column('indexing_jobs', 'files_indexed',
               existing_type=sa.INTEGER(),
               server_default=sa.text('0'),
               nullable=True)
    op.alter_column('indexing_jobs', 'status',
               existing_type=sa.VARCHAR(length=20),
               server_default=sa.text("'pending'::character varying"),
               existing_nullable=False)
    op.alter_column('indexing_jobs', 'id',
               existing_type=sa.UUID(),
               server_default=sa.text('gen_random_uuid()'),
               existing_nullable=False)
    op.drop_column('indexing_jobs', 'force_reindex')
    op.alter_column('embedding_metadata', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               server_default=sa.text('CURRENT_TIMESTAMP'),
               existing_nullable=False)
    op.alter_column('code_files', 'is_deleted',
               existing_type=sa.BOOLEAN(),
               server_default=sa.text('false'),
               existing_nullable=False)
    op.alter_column('code_files', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               server_default=sa.text('CURRENT_TIMESTAMP'),
               existing_nullable=False)
    op.alter_column('code_files', 'indexed_at',
               existing_type=postgresql.TIMESTAMP(),
               server_default=sa.text('CURRENT_TIMESTAMP'),
               existing_nullable=False)
    op.alter_column('code_chunks', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               server_default=sa.text('CURRENT_TIMESTAMP'),
               existing_nullable=False)
    op.drop_constraint(None, 'change_events', type_='foreignkey')
    op.create_foreign_key(op.f('fk_change_events_repository_id_repositories'), 'change_events', 'repositories', ['repository_id'], ['id'], ondelete='CASCADE')
    op.create_index(op.f('ix_change_events_detected_at'), 'change_events', ['detected_at'], unique=False)
    op.alter_column('change_events', 'detected_at',
               existing_type=postgresql.TIMESTAMP(),
               server_default=sa.text('CURRENT_TIMESTAMP'),
               existing_nullable=False)
    op.create_table('task_status_history',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('task_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('from_status', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('to_status', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('changed_at', postgresql.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_task_status_history'))
    )
    op.create_index(op.f('ix_task_status_history_changed_at'), 'task_status_history', ['changed_at'], unique=False)
    op.create_table('search_queries',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('query_text', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('result_count', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('latency_ms', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('filters', postgresql.JSON(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_search_queries'))
    )
    op.create_index(op.f('ix_search_queries_created_at'), 'search_queries', ['created_at'], unique=False)
    op.create_table('task_planning_references',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('task_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('file_path', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('reference_type', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_task_planning_references'))
    )
    op.create_table('task_commit_links',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('task_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('commit_hash', sa.VARCHAR(length=40), autoincrement=False, nullable=False),
    sa.Column('commit_message', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_task_commit_links'))
    )
    op.create_index(op.f('ix_commit_links_task_commit'), 'task_commit_links', ['task_id', 'commit_hash'], unique=True)
    op.create_table('projects',
    sa.Column('id', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('name', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.Column('description', sa.TEXT(), server_default=sa.text("''::text"), autoincrement=False, nullable=True),
    sa.Column('database_name', sa.VARCHAR(length=100), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('updated_at', postgresql.TIMESTAMP(), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('metadata', postgresql.JSONB(astext_type=sa.Text()), server_default=sa.text("'{}'::jsonb"), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('id', name=op.f('projects_pkey')),
    sa.UniqueConstraint('database_name', name=op.f('projects_database_name_key'), postgresql_include=[], postgresql_nulls_not_distinct=False),
    sa.UniqueConstraint('name', name=op.f('projects_name_key'), postgresql_include=[], postgresql_nulls_not_distinct=False)
    )
    op.create_index(op.f('idx_projects_name'), 'projects', ['name'], unique=False)
    op.create_index(op.f('idx_projects_database_name'), 'projects', ['database_name'], unique=False)
    op.create_table('task_branch_links',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('task_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('branch_name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_task_branch_links'))
    )
    op.create_index(op.f('ix_branch_links_task_branch'), 'task_branch_links', ['task_id', 'branch_name'], unique=True)
    # ### end Alembic commands ###
